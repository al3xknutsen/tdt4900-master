import json
import os
import re

import numpy as np
from pxr import UsdGeom, Gf

from chapter_7_position_data.connector_gnss import project_to_utm
from omniverse_utils import start_omniverse, open_stage, save_stage
    
def read_gnss(path):
    # Read contents of the GNSS file
    with open(path) as file_gnss:
        content = file_gnss.readlines()

    data = []
    
    for line in content:
        # Search for info in each file line
        line_search = re.search(r"^GPS\[0\] - (?P<timestamp>\d*) lat: (?P<lat>\d{1,2}(\.\d*)?) lon: (?P<lon>\d{1,2}(\.\d*)?) alt: (?P<alt>\d*(\.\d*)?)( course: (?P<course>\d*(\.\d*)?) speed: (?P<speed>\d*(\.\d*)?) hdop: (?P<hdop>\d*(\.\d*)?) vdop: (?P<vdop>\d*(\.\d*)?))?.*\n$", line)

        if line_search:
            timestamp = int(line_search.group("timestamp"))
            lat = float(line_search.group("lat"))
            lon = float(line_search.group("lon"))
            alt = float(line_search.group("alt"))
            course = float(line_search.group("course")) if line_search.group("course") else None
            speed = float(line_search.group("speed")) if line_search.group("speed") else None
            hdop = float(line_search.group("hdop")) if line_search.group("hdop") else None
            vdop = float(line_search.group("vdop")) if line_search.group("vdop") else None

            data.append({"timestamp": timestamp, "lat": lat, "lon": lon, "alt": alt, "course": course, "speed": speed, "hdop": hdop, "vdop": vdop})
        
    return data

def get_timestamp_from_frame(path, frame):
    # Read file containing timestamps for each video frame
    with open(path) as file_timestamps:
        content = file_timestamps.read()
    
    lines = content.split("\n")

    # Loop through all lines, and stop when the given frame is found
    for line in lines:
        frame_num, timestamp = line.split()
        if frame_num == str(frame):
            return int(timestamp)

def get_location_from_timestamp(path, timestamp):
    gnss = read_gnss(path)

    # Get line number of the smallest timestamp larger
    # or equal to the given timestamp value
    for i, line in enumerate(gnss):
        if line["timestamp"] >= timestamp:
            break
    
    # Get current time, lon, and lat, as well as previous ones
    before, after = gnss[i - 1], gnss[i]
    before_time, after_time = timestamp - before["timestamp"], after["timestamp"] - timestamp
    lat_min, lon_min, alt_min = before["lat"], before["lon"], before["alt"]
    lat_max, lon_max, alt_max = after["lat"], after["lon"], after["alt"]

    # Interpolate values
    def interpolated(value_min, value_max):
        return value_min + (value_max - value_min) / (before_time + after_time) * before_time

    lat = interpolated(lat_min, lat_max)
    lon = interpolated(lon_min, lon_max)
    alt = interpolated(alt_min, alt_max)

    return lon, alt, lat

def get_camera_location_from_frame(path, frame):
    # Read contents of the camera pose file generated by Meshroom
    with open(path) as file_cameras:
        content = json.load(file_cameras)
    
    # Get the view corresponding to the current frame
    for view in content["views"]:
        if frame == int(os.path.splitext(os.path.basename(view["path"]))[0]):
            break
    
    poseid = view["poseId"]

    # Get the camera pose for the current frame
    for pose in content["poses"]:
        if pose["poseId"] == poseid:
            break
    
    # Get the camera location
    location = pose["pose"]["transform"]["center"]
    location = [float(l) for l in location]
    
    return location

# Function for generating affine transformation matrix
def generate_affine_matrix(coords_from, coords_to):
    coords_from = np.array(coords_from)
    coords_to = np.array(coords_to)

    # Calculate rotation
    q = coords_from[1:] - coords_from[0]
    qp = coords_to[1:] - coords_to[0]
    rotation = np.dot(np.linalg.inv(np.row_stack((q, np.cross(*q)))),
                                    np.row_stack((qp, np.cross(*qp))))

    # Calculate translation
    translation = coords_to[0] - np.dot(coords_from[0], rotation)

    # Calculate composite matrix
    return np.column_stack((np.row_stack((rotation, translation)),
                            (0, 0, 0, 1)))

# Function for correcting the y scale of the photogrammetry mesh
# (this is too large for some reason)
def correct_y_scale(matrix):
    # Extract the X, Y, and Z scaling factor respectively
    # from the transformation matrix
    def compute_norm(i):
        return np.linalg.norm(matrix[:,i][:-1])
    
    norm_x = compute_norm(0)
    norm_z = compute_norm(2)

    # The new Y scale should be the average of the X and the Z scales
    norm_y = (norm_x + norm_z) / 2

    # Normalize
    matrix[:,1][:-1] /= norm_y

    return matrix

def add_mesh_to_omniverse(path_file, path_usd, matrix):
    start_omniverse(True)
    stage = open_stage("omniverse://gloshaugen.usd")

    # Add an OBJ reference
    UsdGeom.Xform.Define(stage, path_usd)
    prim = stage.GetPrimAtPath(path_usd)
    prim.GetReferences().AddReference(path_file)

    # Set transformation matrix
    xform = UsdGeom.Xformable(prim)
    transform = xform.MakeMatrixXform()
    transform.Set(Gf.Matrix4d(matrix))

    save_stage(stage)

if __name__ == "__main__":
    # Paths galore
    path_timestamps = "C1_front60Single.h264.timestamps"
    path_gnss = "trip019_gnss50.txt"
    path_cameras = "cameras.sfm"
    path_mesh = "texturedMesh.obj"

    path_xform_photogram = "/Root/photogrammetry"

    # Which frames to use for creating the transformation matrix
    frames = [520, 14770, 15440]

    coords_from = []
    coords_to = []

    # Get original WGS84 frames and translate to Omniverse coordinates
    for frame in frames:
        timestamp = get_timestamp_from_frame(path_timestamps, frame)
        location_car = get_location_from_timestamp(path_gnss, timestamp)
        location_camera = get_camera_location_from_frame(path_cameras, frame)
        location_car_utm = project_to_utm(*location_car)

        coords_from.append(location_camera)
        coords_to.append(location_car_utm)
    
    # Compute transformation matrix
    matrix = generate_affine_matrix(coords_from, coords_to)
    matrix = correct_y_scale(matrix)

    # Add photogrammetry mesh to Omniverse scene
    add_mesh_to_omniverse(path_mesh, path_xform_photogram, matrix)
